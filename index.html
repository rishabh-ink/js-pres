<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>JavaScript</title>

		<meta name="description" content="JavaScript presentation">
		<meta name="author" content="Rishabh Rao">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section data-state="slide-level-one">
					<h1>JavaScript For You!</h1>
				</section>

				<section data-state="slide-level-one">
					<h1>Welcome and thank you for coming!</h2>
				</section>

				<section data-state="slide-level-one">
					<h1>Brag about us!</h2>
				</section>

				<section data-state="slide-level-one">
					<h2>Today&rsquo;s agenda</h2>
					<ol>
						<li class="fragment">History</li>
						<li class="fragment">Basics</li>
						<li class="fragment">Objects</li>
						<li class="fragment">Functions</li>
						<li class="fragment">Inheritance</li>
						<li class="fragment">This</li>
					</ol>
				</section>

				<section data-state="slide-level-one">
					<h1>History</h1>
				</section>

				<section data-state="slide-level-one">
					<h1>Basics</h1>
				</section>

				<section data-state="slide-level-two">
					<h4>Basics</h4>
					<h2>Variables</h2>
				</section>

				<section>
					<h2>Data types</h2>
					<p>There are 6 data types in JavaScript:</p>
					<ol>
						<li class="fragment">String</li>
						<li class="fragment">Number</li>
						<li class="fragment">Object</li>
						<li class="fragment">Boolean</li>
						<li class="fragment"><code>undefined</code></li>
						<li class="fragment"><code>null</code></li>
					</ol>
				</section>

				<section>
					<h2>Variable scope</h2>
					<pre><code>
function doSomething() {
	myVar = &quot;foo&quot;; //this goes into the global scope
	var myOtherVar = &quot;bar&quot;; //this goes into the function scope
}

console.log( myVar ); //foo
console.log( myOtherVar ); //error
</code></pre>
				</section>

				<section>
					<h2>Oops!</h2>
					<pre><code>
function doSometing(){
	for( i = 0; i < 10; i++ ){
   	doMore();
   	console.log( i );
	}
}

function doMore(){
	for( i = 0; i < 10; i++ ){
		//do some stuff
	}
};

doSometing();
					</code></pre>
				</section>

				<section>
					<h2>That's better!</h2>
					<pre><code>
function doSometing() {
  for( var i = 0; i < 10; i++ ) {
    doMore();
    console.log( i );
  }
}

function doMore() {
	for( var i = 0; i < 10; i++ ) {
     	//do some stuff
  	}
};

doSometing();
						</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Basics</h4>
					<h2>Numbers</h2>
				</section>

				<section>
					<h2>Introduction</h2>
					<p class="fragment">All numbers in JavaScript are 64-bit floating point numbers.</p>
					<p class="fragment">Floating point arithmetic sometimes give strange results (<a href="http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html">http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html</a>).</p>
					<pre class="fragment"><code>
var result = 0.06 + 0.01;
console.log( "0.06 + 0.01 = " + result );
						</code></pre>
				</section>

				<section>
					<h2>More about numbers</h2>

					<p class="fragment">
						JavaScript has a <strong>BigNum</strong> library which will improve the accuracy of floating point expressions at <a href="https://github.com/jtobey/javascript-bignum" target="_blank">https://github.com/jtobey/javascript-bignum</a>
					</p>

					<p class="fragment">Use the <code>toFixed()</code> method to round a number to a specified number of decimal places.</p>
					<pre class="fragment"><code>
console.log( 3.14159.toFixed( 2 ) ); // 3.14
					</code></pre>
				</section>

				<section>
					<h2>Not a number?!</h2>
					<p class="fragment"><code>NaN</code>, is a special value in JavaScript. You'll get <code>NaN</code> in situations like trying to do math on a variable that is <code>undefined</code> or trying to perform multiplication, division, or subtraction on a string.</p>
					<ul>
			        <li class="fragment"><code>NaN is False</code></li>
			        <li class="fragment"><code>NaN !== NaN (NaN is not even != NaN)</code></li>
			        <li class="fragment"><code>typeof NaN</code> is number.</li>
			        <li class="fragment">Use <code>isNaN()</code> to test for NaN</li>
			    </ul>
				</section>

				<section data-state="slide-level-two">
					<h4>Basics</h4>
					<h2>Arrays</h2>
				</section>

				<section>
					<h2>Creating arrays</h2>
					<p class="fragment">Arrays can be created two ways:</p>
					<pre class="fragment"><code>var myArray = new Array( 'item1', 'item2', myobj, [] );</code></pre>
					<p class="fragment">and</p>
					<pre class="fragment"><code>var myArray = [ "item1", "item2", myObj, [] ]; //prefered</code></pre>
					<p class="fragment">In order to create multi-dimensional arrays in JavaScript you nest arrays:</p>
					<pre class="fragment"><code>myArray[ 0 ] = [ "nested one", "nested two" ];
					myArray[ 0 ][ 1 ]; //nested two</code></pre>
				</section>

				<section>
					<h2>Array methods</h2>
					<p class="fragment">Arrays are objects so they have methods.</p>

					<pre class="fragment"><code>myArray.length; // mutable in JS, set length to resize arary</code></pre>
					<pre class="fragment"><code>myArray.push( item ); // append item to the end of the array</code></pre>
					<pre class="fragment"><code>myArray.pop(); // removes the last element of the array and returns it</code></pre>
					<pre class="fragment"><code>myArray.concat( anotherArray ); // adds two arrays together, returns a new array. myArray unchanged!</code></pre>
					<pre class="fragment"><code>myArray.join( &quot;,&quot; ); // combines elements into string, separated by argument</code></pre>
					<pre class="fragment"><code>myArray.slice( 1, 2 ) //returns 2 items from the array starting at position 1</code></pre>
					<pre class="fragment"><code>myArray.shift() //removes the first element of the array and returns it</code></pre>
				</section>

				<section>
					<h2>Stack</h2>
					<p class="fragment">Use <code>push()</code> &amp; <code>pop</code> together to create a stack (LIFO)</p>
					<pre class="fragment"><code>
myStack.push( 'Taylor Swift' );

console.log( myStack );

console.log( myStack.pop() );

console.log( myStack )

console.log( myStack.pop() );

console.log( myStack );
					</code></pre>
				</section>

				<section>
					<h2>Queue</h2>
					<p class="fragment">Use <code>push</code> &amp; <code>shift</code> together to create a queue (FIFO)</p>
					<pre class="fragment"><code>
myQueue.push( 'Taylor Swift' );

console.log( myQueue );

console.log( myQueue.shift() );

console.log( myQueue );

console.log( myQueue.shift() );

console.log( myQueue );
					</code></pre>
				</section>

				<section>
					<h2>Deep copy</h2>
					<p class="fragment">Use <code>slice()</code> to make a one-level deep-copy of an array.</p>
					<pre class="fragment"><code>
var myArray = [ 'Aaron', 'Drew', 'Tom', 'Peyton' ];

var myArray2 = myArray; //holds a reference to myArray

var myArray3 = myArray.slice(); //is truly a new array

myArray2[ 2 ] = 'Cam'; // changes myArray

myArray3[ 1 ] = 'Phillip';

console.log( myArray );
console.log( myArray2 );
console.log( myArray3 );
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Basics</h4>
					<h2>Operators</h2>
				</section>

				<section>
					<h2>Comparision</h2>
					<p class="fragment">In JavaScript there are 2 sets of comparison operators:</p>
					<ul>
						<li class="fragment">Type coercion operators: <code>==</code> and <code>!=</code></li>
						<li class="fragment">Non-type coercion operators (a.k.a. exactly equal): <code>===</code> and <code>!==</code></li>
					</ul>
				</section>

				<section>
					<h2>What exactly is type coersion?</h2>
					<pre class="fragment"><code>
console.log( "1" == 1 );

console.log( "1" === 1 );

console.log( [7] == 7 );

console.log( [7] === 7 );

console.log( false == '' );

console.log( false === '' );
					</code></pre>
					<p class="fragment">Always use === when comparing a variable <code>0</code>, <code>undefined</code>, booleans, <code>null</code>, and empty strings "".</strong></p>
				</section>

				<section>
					<h2>Truthy and Falsy Values</h2>
					<p class="fragment">The following values evaluate to <code>false</code>, since some of them not primitive boolean datatypes they are said to be "falsy".</p>
					<ul>
						<li><code>false</code></li>
						<li><code>0</code></li>
						<li><code>""</code></li>
						<li><code>undefined</code></li>
						<li><code>NaN</code></li>
						<li><code>null</code></li>
					</ul>
					<p class="fragment"><strong>Anything that is not falsy is truthy in JavaScript.</strong></p>
				</section>

				<section data-state="slide-level-two">
					<h2>Logical operators</h2>
				</section>

				<section>
					<h2>OR operator</h2>
					<p class="fragment">The <code>||</code> operator returns the value of the first expression if it's true otherwise returns the value of the second expression.</p>
					<pre class="fragment"><code>
console.log( null || "hello" );

console.log( "world" || "foo" );
					</code></pre>
				</section>

				<section>
					<h2>Using OR operator for assigning default values</h2>
					<p class="fragment">The <code>||</code> operator can be used to set default values.</p>
					<pre class="fragment"><code>
var myFunc = function( arg ){

	var myVal =
		document.getElementById( arg ) ||
		document.createElement( &quot;div&quot; ); // defaultValue

	console.log( myVal );
};

myFunc( );
myFunc( &quot;andor3&quot; );
					</code></pre>
				</section>

				<section>
					<h2>AND operator</h2>
					<p class="fragment">The <code>&amp;&amp;</code> returns the value of the first expression if it is false, otherwise it returns the value of the second.</p>
					<pre class="fragment"><code>
console.log( 1 - 1 &amp;&amp; "Foo" );

console.log( 1 + 1 &amp;&amp; "Bar" );
					</code></pre>
				</section>

				<section>
					<h2>Ternary operator</h2>
					<p class="fragment">The ternary operator is a terse way to do a simple if/else statement.</p>
					<pre class="fragment"><code>
var myVar = 10;

var myValue = ( myVar &lt; 10 ) ? 'lesser' : 'greater';

console.log( myValue );
					</code></pre>

					<pre class="fragment"><code>
var myVar = 10,
	 myValue;

if(myVar &lt; 10) {
	myValue = 'lesser';
} else {
	myValue = 'greater';
}

console.log( myValue );
					</code></pre>
				</section>

				<section data-state="slide-level-one">
					<h1>Objects</h1>
				</section>

				<section data-state="slide-level-two">
					<h4>Objects</h4>
					<h2>Object Basics</h2>
				</section>

				<section>
					<h2>Introduction</h2>
					<p class="fragment">Objects in JavaScript can be thought of as a set of key-value pairs.</p>
					<pre class="fragment"><code>
myObject = { }; //empty object

myObject2 = {
    foo : &quot;Foo&quot;,
    bar : &quot;Bar&quot;,
    anotherObject : {
        baz : &quot;Baz&quot;,
        pez : &quot;Pez&quot;
    }
}; //this is called an object literal pattern
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Objects</h4>
					<h2>Retrival</h2>
				</section>

				<section>
					<h2>Object access</h2>
					<p>You can access an object's properties with "dot" notation or with associative array notation.</p>
					<pre class="fragment"><code>
var myObject = {
    foo : 'Foo'
};

myObject[ 'foo bar' ] = 'foo bar'; // non standard property names

console.log( myObject.foo );

console.log( myObject[ 'foo' ] );

console.log( myObject ['foo ' + 'bar' ] );
					</code></pre>
				</section>

				<section>
					<h2>Access object properties from methods</h2>
					<p class="fragment">When accessing properties from other properties in an object, use the <code>this</code> keyword.</p>
					<pre class="fragment"><code>
var myObj = {

    firstName : 'Homer',

    sayHello : function(){
        //omitting the this keyword below would generate an error
        console.log( 'Hello, ' + this.firstName );
    }
};

myObj.sayHello();
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Objects</h4>
					<h2>Own Property</h2>
				</section>

				<section>
					<h2>hasOwnProperty()</h2>
					<p>To check if a property exists in an object use the <code>hasOwnProperty()</code> method or the <code>in</code> operator. <code>hasOwnProperty</code> will only search the current object for a property whereas <code>in</code> will search all the way up the prototype chain.</p>
					<pre class="fragment"><code>
var myObject = {foo : 'Foo'};

myObject.__proto__ = { baz : "Baz" }; //we'll talk about this later

console.log( 'baz' in myObject );

console.log( myObject.hasOwnProperty( 'baz' ) );
					</code></pre>
				</section>

				<section data-state="slide-level-one">
					<h1>Functions</h1>
				</section>

				<section>
					<h3>Introduction</h3>
					<p class="fragment">JavaScript functions are the beating heart of a JavaScript application and are one of the most powerful features of the language.</p>
					<ul>
						<li class="fragment">All functions return something!  If there is no <code>return</code> statement a function will return the keyword <code>undefined</code>.</li>
						<li class="fragment">Functions can have properties just like objects.</li>
					</ul>
				</section>

				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>Creating functions</h2>
				</section>

				<section>
					<h3>Two ways of creating functions</h3>
					<pre class="fragment"><code>
function myFunc( args ) {
    ...
};
					</code></pre>
					<pre class="fragment"><code>
var myFunc = function( args ) {
    ...
};
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>Hoisting</h2>
				</section>

				<section>
					<h3>Function hoisting</h3>
					<p class="fragment">There is one fundamental difference between function expressions and statements: hoisting.  Hoisting is when the JavaScript parser takes a function and variable declarations and moves them to the top of the current scope.</p>
				</section>

				<section>
					<h3>Function Declaration Before Hoisting</h3>
					<pre class="fragment"><code>
function hoistingExample(){
    var firstVar;

    firstVar = &quot;&quot;;

    var secondVar = &quot;&quot;;

    secondFunction( firstVar + secondVar );

    firstFunction(); //throws an error

    var firstFunction = function(){
        //do something
    };

    function secondFunction(){
        // do another thing
    }
}
					</code></pre>
				</section>

				<section>
					<h3>Function Declaration After Hoisting</h3>
					<pre class="fragment"><code>
function hoistingExample(){
    //the function statement has been brought to the top of the scope
    function secondFunction(){
        // do another thing
    }

    //declared the variables
    var firstVar;
    var secondVar;
    var firstFun;

    //instantiate the variables where they are in the code
    firstVar = &quot;&quot;;

    secondVar = &quot;&quot;;

    secondFunction( firstVar + secondVar );

    firstFunction();

    firstFunction = function(){
        //do something
    }
}
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>Arguments</h2>
				</section>

				<section>
					<p class="fragment">Arguments in JavaScript are stored in an array-like object.  The "arguments" object has a length property but none of the other array methods.</p>
					<pre class="fragment"><code>
var myFunc = function(){
    console.log( arguments );
};

myFunc( &quot;Hello&quot;, &quot;World&quot;, function(){} );
					</code></pre>
				</section>


				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>typeof</h2>
				</section>

				<section>
					<p class="fragment">Since JavaScript is a type-less language its always a good idea to check the type of arguments.</p>
					<p class="fragment">To do this we are provided with the <code>typeof</code> operator.</p>
					<pre class="fragment"><code>
console.log("Type of string: " + typeof "hello");

console.log( "Type of number: " + typeof 1234 );

console.log( "Type of object literal: " + typeof {} );

console.log( "Type of array: " + typeof [] ); //be carefull!

console.log( "Type of function: " + typeof function(){} );

console.log( "Type of function: " + typeof undefinedVar );
					</code></pre>
				</section>

				<section>
					<p class="fragment">To check if a variable is defined or not you can use the <code>typeof</code> operator on it.</p>
					<p class="fragment">Doing <code>if( undefinedVar === 'undefined')</code> will throw an error.</p>
				</section>


				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>typeof for arrays</h2>
				</section>

				<section>
					<pre class="fragment"><code>console.log( typeof [] ); //object ?!?</code></pre>
					<p class="fragment"></p>
					<pre class="fragment"><code>
//borrowed from Douglas Crockford&#39;s &quot;JavaScript: The Good Parts&quot;
var is_array = function ( value ) {
    return Object.prototype.toString.apply( value ) === &#39;[object Array]&#39;;
};
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>arguments pass by value</h2>
				</section>

				<section>
					<p class="fragment">All arguments JavaScript are passed <strong>by value</strong>, even though they act like they are being passed by reference.</p>
					<pre class="fragment"><code>
function createCar(){
    var myCar = { make : "Ford", model : "Fusion" };

    changeCar( myCar );

    //if mycar was passed by ref it would now be a Honda!
    console.log(myCar);
}

function changeCar( theObj ){

    theObj.make = "Chevy";
    theObj.model = "Traverse";

    theObj = {}; //this breaks the link between the value passed in and its reference
    theObj.make = "Honda";

    console.log( theObj );
}

createCar();
					</code></pre>
				</section>

				<section>
					<p class="fragment">A variable that holds an object is a pointer to the memory location of that object.  When the argument is passed a copy is made of that pointer.  When a new object is created the pointer now points to a different memory location.</p>
					<!-- TODO Add image here -->
					<img src="" alt="" class="fragment" />
				</section>

				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>Lexical scoping</h2>
				</section>

				<section>
					<p class="fragment">Functions can be nested inside of other functions.  Each nested function has access to the scope of all its parents.  This is called lexical scoping. </p>
					<pre class="fragment">
var lexical = function(){
    var outerVar = 'outer';

    return function(){

        var innerVar = "inner"; //outer function does not have access

        console.log( outerVar );

            return function(){
                console.log( innerVar, outerVar );
            }();
    }();
};

lexical();
					</pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>Closures</h2>
				</section>

				<section>
					<ul>
						<li class="fragment">Closures are created when a reference exists to a variable inside a function after that function has been invoked.</li>
						<li class="fragment">The execution context of that variables scope is saved and "wrapped" around that variable.</li>
						<li class="fragment">This effectively saves the "state" of that variables entire scope at the time the function is run.</li>
					</ul>
				</section>

				<section>
					<pre class="fragment"><code>
var timesCalled = function(){
    var total = 0;

    return function(){
        total++;
        console.log( total );
    };

};

var callTimer = timesCalled(); //this call right here creates the closure

callTimer();
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>Functions</h4>
					<h2>Constructor functions</h2>
				</section>

				<section>
					<p class="fragment">JavaScript has a special type of function called a <code>Constructor</code> function.</p>
					<ul>
						<li class="fragment">By convention the first letter of a constructor should be a capital letter.</li>
						<li class="fragment">Never use a constructor function without first using the <code>new</code> keyword!</li>
						<li class="fragment">Using the new keyword will create a new scope for the function.</li>
						<li class="fragment">Using the new keyword will also create the inheritance tree. Without new a function will only inherit from the Function Constructor.</li>
					</ul>
				</section>

				<section>
					<pre><code>
//create a new constuctor function called Robot
var Robot = function( robotName ){
    this.robotName = robotName;
};

//add a new property to the prototype (more on this soon)
Robot.prototype.walk = function(){
    console.log( "Go " + this.robotName + " go!" );
};

//create a new instance of the robot using the new keyword
var robot = new Robot( "Ferbbot" );

//now we can tell the robot to walk
robot.walk();

var anotherRobot = Robot( "Phineasbot" ); //we just created a global!!

console.log( window.robotName ); //note that robotName is now a property of window

//anotherRobot.walk(); //doesn't exist
					</code></pre>
				</section>

				<section>
					<p class="fragment">Create a new variable for our constructor function.  Make sure the name starts with a capital letter!</p>
					<pre class="fragment"><code>
var Robot = function( robotName ){
	this.robotName = robotName;
};
					</code></pre>
				</section>

				<section>
					<p class="fragment">Now add a new property to the prototype of the constructor.</p>
					<p class="fragment">This is initialized with the prototype chain when the <code>new</code> keyword is used.</p>
					<pre class="fragment"><code>
Robot.prototype.walk = function(){
    console.log( "Go " + this.robotName + " go!" );
};
					</code></pre>
				</section>

				<section>
					<p class="fragment">Correct.</p>
					<pre class="fragment"><code>var robot = new Robot( "Ferbbot" );</code></pre>
					<p class="fragment">Incorrect, not using the keyword does not create a scope or a prototype chain.</p>
					<pre class="fragment"><code>var anotherRobot = Robot( "Phineasbot" );</code></pre>
				</section>

				<section data-state="slide-level-one">
					<h1>This</h1>
				</section>

				<section data-state="slide-level-two">
					<h4>This</h4>
					<h2>Intro</h2>
				</section>

				<section>
					<p class="fragment">The <code>this</code> keyword one of JavaScript's most mis-understood keywords.</p>
					<pre class="fragment"><code>
var myObj = {
    myFunc : function() {
        console.log(this);
    }
};

var myFunc = function() {
    console.log(this);
};

myObj.myFunc();
myFunc();
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>This</h4>
					<h2>Execution context</h2>
				</section>

				<section>
					<p class="fragment">What happened in the function call?  Why did this point to window and not the function?</p>
					<p class="fragment">In order to explain we must understand what "this" means in JavaScript.  This refers to the <strong>current execution context.</strong></p>
					<p class="fragment">When we called the myFunc function from within the object, the object was the current execution context.</p>
					<p class="fragment">When we called <code>myFunc()</code> from the root of the script tag, the window object was the current execution context.</p>
				</section>

				<section data-state="slide-level-two">
					<h4>This</h4>
					<h2>call() and apply()</h2>
				</section>

				<section>
					<p class="fragment">The <code>call(this,arg1, arg2, arg3, ...)</code> and <code>apply(this,[args])</code> functions allow you to pass the value of <code>this</code> as the first parameter.</p>
					<p class="fragment">The difference is that the call function takes in any number of arguments whereas the apply function takes an array of arguments as its second argument.</p>
					<pre class="fragment"><code>
function whoAmI(){
    console.log( "I am: " + this );

    console.log( arguments );
}

whoAmI.call( "Ryan", "Hello World", undefined, {}, [] );

whoAmI.apply( "Scott", [ "Hello World", undefined, {}, [] ] );
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>This</h4>
					<h2>this in constructor functions</h2>
				</section>

				<section>
					<pre><code>
function Person( name ){
    this.name = name;

    console.log( this );
    console.log( this.name );
}

var person = new Person( &quot;Bart&quot; );
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>This</h4>
					<h2>this in object literals</h2>
				</section>

				<section>
					<pre><code>
var myObj = {
    firstName : "Homer",

    sayHello : function(){

        //omitting this would cause an error
        console.log( "Hello, " + this.firstName );
    }
};

myObj.sayHello();
					</code></pre>
				</section>

				<section data-state="slide-level-two">
					<h4>This</h4>
					<h2>this in nested functions</h2>
				</section>

				<section>
					<pre><code>
var myObj = {
    firstName : &quot;Homer&quot;,

    sayHello : function(){
        //look what happens when this is used inside a nested function
        return function(){
            console.log( &quot;Hello, &quot; + this.firstName );
            console.log( this );
        };
    }
};

myObj.sayHello();
					</code></pre>
					<p class="fragment">In nested functions <code>this</code> refers back to global namespace!</p>
				</section>

				<section data-state="slide-level-two">
					<h4>This</h4>
					<h2>More links on this</h2>
				</section>

				<section>
					<p class="fragment">For a much more comprehensive look at "this" and "function invocation" read:
					<p class="fragment">Yehuda Kat's blog post: <a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank">http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/</a></p>
					<p class="fragment">Scope In JavaScript: <a href="http://www.digital-web.com/articles/scope_in_javascript/">http://www.digital-web.com/articles/scope_in_javascript/</a></p>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
